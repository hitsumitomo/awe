//
// Code generated by awec. DO NOT EDIT.
//
// 2024-10-31T21:45:36Z
//

package test

import (
	"bytes"
	"compress/gzip"
	"encoding/binary"
	"github.com/hitsumitomo/awe"
	"hash/adler32"
	"io"
	"math"
)

func (e *Example) Marshal(flags ...byte) ([]byte, error) {
	var flag byte
	if len(flags) > 0 {
		flag = flags[0]
	}

	size := 6 + 1 + 1 + 2 + 2 + 4 + 4 + 8 + 8 + 1 + 4 + 8 + 4 + len(e.StringField) + 4 + len(e.BytesField) + 64 + 1
	offset := 0

	// Skip Crc32 if awe.Compress is set
	if flag&awe.Compress > 0 {
		flag &^= awe.Crc32
	}

	if flag&awe.Crc32 > 0 {
		size += 4
		offset += 4
	}

	buf := make([]byte, size)
	buf[0] = flag
	buf[1] = buf[0] ^ 0xFF
	offset += 2

	binary.LittleEndian.PutUint32(buf[2:], uint32(size))
	offset += 4
	buf[offset] = byte(e.Int8Field)
	offset += 1
	buf[offset] = e.Uint8Field
	offset += 1
	binary.LittleEndian.PutUint16(buf[offset:], uint16(e.Int16Field))
	offset += 2
	binary.LittleEndian.PutUint16(buf[offset:], e.Uint16Field)
	offset += 2
	binary.LittleEndian.PutUint32(buf[offset:], uint32(e.Int32Field))
	offset += 4
	binary.LittleEndian.PutUint32(buf[offset:], e.Uint32Field)
	offset += 4
	binary.LittleEndian.PutUint64(buf[offset:], uint64(e.Int64Field))
	offset += 8
	binary.LittleEndian.PutUint64(buf[offset:], e.Uint64Field)
	offset += 8
	buf[offset] = e.ByteField
	offset += 1
	binary.LittleEndian.PutUint32(buf[offset:], math.Float32bits(e.Float32Field))
	offset += 4
	binary.LittleEndian.PutUint64(buf[offset:], math.Float64bits(e.Float64Field))
	offset += 8
	stringLength := uint32(len(e.StringField))
	binary.LittleEndian.PutUint32(buf[offset:], stringLength)
	offset += 4
	copy(buf[offset:], e.StringField)
	offset += int(stringLength)
	bytesLength := uint32(len(e.BytesField))
	binary.LittleEndian.PutUint32(buf[offset:], bytesLength)
	offset += 4
	copy(buf[offset:], e.BytesField)
	offset += int(bytesLength)
	copy(buf[offset:], e.ArrayField[:])
	offset += 64
	if e.Bool {
		buf[offset] = 1
	} else {
		buf[offset] = 0
	}
	offset += 1

	if flag&awe.Crc32 > 0 {
		crc := adler32.Checksum(buf[10:offset])
		binary.LittleEndian.PutUint32(buf[6:], crc)
	}

	if flag&awe.Compress > 0 {
		result := &bytes.Buffer{}
		result.Write(buf[:awe.MarkerSize+4]) // marker + length
		w := gzip.NewWriter(result)
		if _, err := w.Write(buf[awe.MarkerSize+4:]); err != nil {
			return nil, err
		}
		if err := w.Close(); err != nil {
			return nil, err
		}
		binary.LittleEndian.PutUint32(result.Bytes()[2:], uint32(result.Len()))
		return result.Bytes(), nil
	}

	return buf, nil
}
func (e *Example) Unmarshal(data []byte) error {
	flag := data[0]

	offset := 0
	if len(data) < 2 || data[1] != (data[0]^0xFF) {
		return awe.ErrInvalidPacket
	}
	offset += 2

	if len(data) < offset+4 {
		return io.ErrUnexpectedEOF
	}

	expectedSize := binary.LittleEndian.Uint32(data[offset:])
	if len(data) < int(expectedSize) {
		return io.ErrUnexpectedEOF
	}
	offset += 4

	if flag&awe.Compress > 0 {
		var result bytes.Buffer
		reader, err := gzip.NewReader(bytes.NewReader(data[offset:]))
		if err != nil {
			return err
		}
		if _, err := io.Copy(&result, reader); err != nil {
			return err
		}
		reader.Close()
		data = result.Bytes()
		offset = 0
	}

	if flag&awe.Crc32 > 0 {
		if len(data) < offset+4 {
			return io.ErrUnexpectedEOF
		}
		crc := binary.LittleEndian.Uint32(data[offset:])
		offset += 4
		if crc != adler32.Checksum(data[offset:]) {
			return awe.ErrInvalidPacket
		}
	}
	e.Int8Field = int8(data[offset])
	offset += 1

	e.Uint8Field = data[offset]
	offset += 1

	e.Int16Field = int16(binary.LittleEndian.Uint16(data[offset:]))
	offset += 2

	e.Uint16Field = binary.LittleEndian.Uint16(data[offset:])
	offset += 2

	e.Int32Field = int32(binary.LittleEndian.Uint32(data[offset:]))
	offset += 4

	e.Uint32Field = binary.LittleEndian.Uint32(data[offset:])
	offset += 4

	e.Int64Field = int64(binary.LittleEndian.Uint64(data[offset:]))
	offset += 8

	e.Uint64Field = binary.LittleEndian.Uint64(data[offset:])
	offset += 8

	e.ByteField = data[offset]
	offset += 1

	e.Float32Field = math.Float32frombits(binary.LittleEndian.Uint32(data[offset:]))
	offset += 4

	e.Float64Field = math.Float64frombits(binary.LittleEndian.Uint64(data[offset:]))
	offset += 8

	length := binary.LittleEndian.Uint32(data[offset:])
	offset += 4
	if flag&awe.Crc32 == 0 && len(data) < offset+int(length) {
		return io.ErrUnexpectedEOF
	}
	if length > 0 {
		e.StringField = string(data[offset : offset+int(length)])
	}
	offset += int(length)

	length = binary.LittleEndian.Uint32(data[offset:])
	offset += 4
	if flag&awe.Crc32 == 0 && len(data) < offset+int(length) {
		return io.ErrUnexpectedEOF
	}
	if length > 0 {
		if flag&awe.FastUnmarshal > 0 {
			e.BytesField = data[offset : offset+int(length)]
		} else {
			e.BytesField = make([]byte, length)
			copy(e.BytesField, data[offset:offset+int(length)])
		}
	}
	offset += int(length)

	if flag&awe.Crc32 == 0 && len(data) < offset+64 {
		return io.ErrUnexpectedEOF
	}
	copy(e.ArrayField[:], data[offset:offset+64])
	offset += 64

	e.Bool = data[offset] == 1
	offset += 1

	return nil
}
