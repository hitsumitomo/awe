package main

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"os"
	"strings"
	"time"
)

func main() {
	if len(os.Args) < 2 {
		fmt.Println("Usage: awec <file_with_structures.go>")
		return
	}

	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, os.Args[1], nil, parser.AllErrors)
	if err != nil {
		fmt.Println("Error parsing file:", err)
		return
	}
	fmt.Printf("Parsing file: %v\n", os.Args[1])

	var structs []StructInfo

	ast.Inspect(node, func(n ast.Node) bool {
		ts, ok := n.(*ast.TypeSpec)
		if ok {
			if st, ok := ts.Type.(*ast.StructType); ok {
				structInfo := StructInfo{
					Name:   ts.Name.Name,
					Fields: []FieldInfo{},
				}
				for _, field := range st.Fields.List {
					for _, name := range field.Names {
						if ast.IsExported(name.Name) {
							fieldType := getType(field.Type)
							switch fieldType {
							case "int8", "uint8", "byte", "bool", "int16", "uint16", "int32", "uint32", "int64", "uint64",
								"float32", "float64", "string", "[]byte":
								fieldInfo := FieldInfo{
									Name: name.Name,
									Type: fieldType,
								}
								structInfo.Fields = append(structInfo.Fields, fieldInfo)

							default:
								if strings.HasPrefix(fieldType, "[") && strings.HasSuffix(fieldType, "]byte") {
									fieldInfo := FieldInfo{
										Name: name.Name,
										Type: fieldType,
									}
									structInfo.Fields = append(structInfo.Fields, fieldInfo)
								}
							}
						}
					}
				}
				structs = append(structs, structInfo)
			}
		}
		return true
	})

	if len(structs) == 0 {
		fmt.Println("No structs found")
		return
	}

	var sb bytes.Buffer
	sb.WriteString("//\n// Code generated by awec. DO NOT EDIT.\n//\n")
	fmt.Fprintf(&sb, "// %v\n//\n\n", time.Now().UTC().Format(time.RFC3339))
	fmt.Fprintf(&sb, "package %s\n\n", node.Name.Name)
	sb.WriteString(`import (
	"bytes"
	"compress/gzip"
	"encoding/binary"
	"hash/adler32"
	"io"
	"math"
	"github.com/hitsumitomo/awe"
)
`)

	for _, structInfo := range structs {
		generateMarshalFunction(&sb, structInfo)
		generateUnmarshalFunction(&sb, structInfo)
		fmt.Printf("Marshal,Unmarshal methods for struct \"%s\" successfuly generated.\n", structInfo.Name)
	}

	formatted, err := format.Source(sb.Bytes())
	if err != nil {
		os.WriteFile("awec_marshalling_error.go", sb.Bytes(), 0644)
		fmt.Println("Error formatting source:", err)
		return
	} else {
		os.Remove("awec_marshalling_error.go")
	}

	file, err := os.Create(strings.Replace(os.Args[1], ".go", "_marshalling.go", 1))
	if err != nil {
		fmt.Println("Error creating file:", err)
		return
	}
	defer file.Close()
	file.Write(formatted)
}

type StructInfo struct {
	Name   string
	Fields []FieldInfo
}

type FieldInfo struct {
	Name string
	Type string
}

func getType(expr ast.Expr) string {
	switch t := expr.(type) {
	case *ast.Ident:
		return t.Name

	case *ast.ArrayType:
		if elt, ok := t.Elt.(*ast.Ident); ok && elt.Name == "byte" {
			if t.Len == nil {
				return "[]byte"
			} else if len, ok := t.Len.(*ast.BasicLit); ok {
				return fmt.Sprintf("[%s]byte", len.Value)
			}
		}
	}
	return fmt.Sprintf("%T", expr)
}

func generateMarshalFunction(sb *bytes.Buffer, structInfo StructInfo) {
	sb.WriteString(fmt.Sprintf("func (e *%s) Marshal(flags ...byte) ([]byte, error) {\n", structInfo.Name))
	sb.WriteString("\tvar flag byte\n")
	sb.WriteString("\tif len(flags) > 0 {\n")
	sb.WriteString("\t\tflag = flags[0]\n")
	sb.WriteString("\t}\n\n")

	sb.WriteString("\tsize := 6") // Начинаем с 6 байт для хранения длины всей структуры и 2 синхробайтов

	for _, field := range structInfo.Fields {
		switch field.Type {
		case "int8", "uint8", "byte", "bool":
			sb.WriteString(" + 1")
		case "int16", "uint16":
			sb.WriteString(" + 2")
		case "int32", "uint32", "float32":
			sb.WriteString(" + 4")
		case "int64", "uint64", "float64":
			sb.WriteString(" + 8")
		case "string":
			sb.WriteString(fmt.Sprintf(" + 4 + len(e.%s)", field.Name))
		case "[]byte":
			sb.WriteString(fmt.Sprintf(" + 4 + len(e.%s)", field.Name))
		default:
			if strings.HasPrefix(field.Type, "[") && strings.HasSuffix(field.Type, "]byte") {
				arraySize := strings.TrimPrefix(field.Type, "[")
				arraySize = strings.TrimSuffix(arraySize, "]byte")
				sb.WriteString(fmt.Sprintf(" + %s", arraySize))
			}
		}
	}

	sb.WriteString(`
	offset := 0

	// Skip Crc32 if awe.Compress is set
	if flag & awe.Compress > 0 {
		flag &^= awe.Crc32
	}

	if flag & awe.Crc32 > 0 {
		size += 4
		offset += 4
	}

	buf := make([]byte, size)
	buf[0] = flag
	buf[1] = buf[0] ^ 0xFF
	offset += 2

	binary.LittleEndian.PutUint32(buf[2:], uint32(size))
	offset += 4
	`)

	for _, field := range structInfo.Fields {
		switch field.Type {
		case "int8":
			fmt.Fprintf(sb, "\tbuf[offset] = byte(e.%s)\n", field.Name)
			sb.WriteString("\toffset += 1\n")
		case "uint8", "byte":
			fmt.Fprintf(sb, "\tbuf[offset] = e.%s\n", field.Name)
			sb.WriteString("\toffset += 1\n")
		case "bool":
			fmt.Fprintf(sb, "\tif e.%s {\n", field.Name)
			sb.WriteString("\t\tbuf[offset] = 1\n")
			sb.WriteString("\t} else {\n")
			sb.WriteString("\t\tbuf[offset] = 0\n")
			sb.WriteString("\t}\n")
			sb.WriteString("\toffset += 1\n")
		case "int16":
			fmt.Fprintf(sb, "\tbinary.LittleEndian.PutUint16(buf[offset:], uint16(e.%s))\n", field.Name)
			sb.WriteString("\toffset += 2\n")
		case "uint16":
			fmt.Fprintf(sb, "\tbinary.LittleEndian.PutUint16(buf[offset:], e.%s)\n", field.Name)
			sb.WriteString("\toffset += 2\n")
		case "int32":
			fmt.Fprintf(sb, "\tbinary.LittleEndian.PutUint32(buf[offset:], uint32(e.%s))\n", field.Name)
			sb.WriteString("\toffset += 4\n")
		case "uint32":
			fmt.Fprintf(sb, "\tbinary.LittleEndian.PutUint32(buf[offset:], e.%s)\n", field.Name)
			sb.WriteString("\toffset += 4\n")
		case "float32":
			fmt.Fprintf(sb, "\tbinary.LittleEndian.PutUint32(buf[offset:], math.Float32bits(e.%s))\n", field.Name)
			sb.WriteString("\toffset += 4\n")
		case "int64":
			fmt.Fprintf(sb, "\tbinary.LittleEndian.PutUint64(buf[offset:], uint64(e.%s))\n", field.Name)
			sb.WriteString("\toffset += 8\n")
		case "uint64":
			fmt.Fprintf(sb, "\tbinary.LittleEndian.PutUint64(buf[offset:], e.%s)\n", field.Name)
			sb.WriteString("\toffset += 8\n")
		case "float64":
			fmt.Fprintf(sb, "\tbinary.LittleEndian.PutUint64(buf[offset:], math.Float64bits(e.%s))\n", field.Name)
			sb.WriteString("\toffset += 8\n")
		case "string":
			fmt.Fprintf(sb, "\tstringLength := uint32(len(e.%s))\n", field.Name)
			sb.WriteString("\tbinary.LittleEndian.PutUint32(buf[offset:], stringLength)\n")
			sb.WriteString("\toffset += 4\n")
			fmt.Fprintf(sb, "\tcopy(buf[offset:], e.%s)\n", field.Name)
			fmt.Fprintf(sb, "\toffset += int(stringLength)\n")
		case "[]byte":
			fmt.Fprintf(sb, "\tbytesLength := uint32(len(e.%s))\n", field.Name)
			sb.WriteString("\tbinary.LittleEndian.PutUint32(buf[offset:], bytesLength)\n")
			sb.WriteString("\toffset += 4\n")
			fmt.Fprintf(sb, "\tcopy(buf[offset:], e.%s)\n", field.Name)
			fmt.Fprintf(sb, "\toffset += int(bytesLength)\n")
		default:
			if strings.HasPrefix(field.Type, "[") && strings.HasSuffix(field.Type, "]byte") {
				sb.WriteString(fmt.Sprintf("\tcopy(buf[offset:], e.%s[:])\n", field.Name))
				arraySize := strings.TrimPrefix(field.Type, "[")
				arraySize = strings.TrimSuffix(arraySize, "]byte")
				sb.WriteString(fmt.Sprintf("\toffset += %s\n", arraySize))
			}
		}
	}

	sb.WriteString(`
	if flag & awe.Crc32 > 0 {
		crc := adler32.Checksum(buf[10:offset])
		binary.LittleEndian.PutUint32(buf[6:], crc)
	}

	if flag & awe.Compress > 0 {
		result := &bytes.Buffer{}
		result.Write(buf[:awe.MarkerSize+4]) // marker + length
		w := gzip.NewWriter(result)
		if _, err := w.Write(buf[awe.MarkerSize+4:]); err != nil {
			return nil, err
		}
		if err := w.Close(); err != nil {
			return nil, err
		}
		binary.LittleEndian.PutUint32(result.Bytes()[2:], uint32(result.Len()))
		return result.Bytes(), nil
	}

	return buf, nil
}
`)
}

func generateUnmarshalFunction(sb *bytes.Buffer, structInfo StructInfo) {
	sb.WriteString(fmt.Sprintf("func (e *%s) Unmarshal(data []byte) error {\n", structInfo.Name))
	sb.WriteString(`flag := data[0]

	offset := 0
	if len(data) < 2 || data[1] != (data[0] ^ 0xFF) {
		return awe.ErrInvalidPacket
	}
	offset += 2

	if len(data) < offset + 4 {
		return io.ErrUnexpectedEOF
	}

	expectedSize := binary.LittleEndian.Uint32(data[offset:])
	if len(data) < int(expectedSize) {
		return io.ErrUnexpectedEOF
	}
	offset += 4

	if flag & awe.Compress > 0 {
		var result bytes.Buffer
		reader,err := gzip.NewReader(bytes.NewReader(data[offset:]))
		if err != nil {
			return err
		}
		if _, err := io.Copy(&result, reader); err != nil {
			return err
		}
		reader.Close()
		data = result.Bytes()
		offset = 0
	}

	if flag & awe.Crc32 > 0 {
		if len(data) < offset + 4 {
			return io.ErrUnexpectedEOF
		}
		crc := binary.LittleEndian.Uint32(data[offset:])
		offset += 4
		if crc != adler32.Checksum(data[offset:]) {
			return awe.ErrInvalidPacket
		}
	}
	`)

	for _, field := range structInfo.Fields {
		switch field.Type {
		case "int8":
			fmt.Fprintf(sb, "\te.%s = int8(data[offset])\n", field.Name)
			sb.WriteString("\toffset += 1\n\n")
		case "uint8", "byte":
			fmt.Fprintf(sb, "\te.%s = data[offset]\n", field.Name)
			sb.WriteString("\toffset += 1\n\n")
		case "bool":
			fmt.Fprintf(sb, "\te.%s = data[offset] == 1\n", field.Name)
			sb.WriteString("\toffset += 1\n\n")
		case "int16":
			fmt.Fprintf(sb, "\te.%s = int16(binary.LittleEndian.Uint16(data[offset:]))\n", field.Name)
			sb.WriteString("\toffset += 2\n\n")
		case "uint16":
			fmt.Fprintf(sb, "\te.%s = binary.LittleEndian.Uint16(data[offset:])\n", field.Name)
			sb.WriteString("\toffset += 2\n\n")
		case "int32":
			fmt.Fprintf(sb, "\te.%s = int32(binary.LittleEndian.Uint32(data[offset:]))\n", field.Name)
			sb.WriteString("\toffset += 4\n\n")
		case "uint32":
			fmt.Fprintf(sb, "\te.%s = binary.LittleEndian.Uint32(data[offset:])\n", field.Name)
			sb.WriteString("\toffset += 4\n\n")
		case "float32":
			fmt.Fprintf(sb, "\te.%s = math.Float32frombits(binary.LittleEndian.Uint32(data[offset:]))\n", field.Name)
			sb.WriteString("\toffset += 4\n\n")
		case "int64":
			fmt.Fprintf(sb, "\te.%s = int64(binary.LittleEndian.Uint64(data[offset:]))\n", field.Name)
			sb.WriteString("\toffset += 8\n\n")
		case "uint64":
			fmt.Fprintf(sb, "\te.%s = binary.LittleEndian.Uint64(data[offset:])\n", field.Name)
			sb.WriteString("\toffset += 8\n\n")
		case "float64":
			fmt.Fprintf(sb, "\te.%s = math.Float64frombits(binary.LittleEndian.Uint64(data[offset:]))\n", field.Name)
			sb.WriteString("\toffset += 8\n\n")
		case "string":
			sb.WriteString("\tlength := binary.LittleEndian.Uint32(data[offset:])\n")
			sb.WriteString("\toffset += 4\n")
			sb.WriteString("\tif flag & awe.Crc32 == 0 && len(data) < offset + int(length) {\n")
			sb.WriteString("\t\treturn io.ErrUnexpectedEOF\n")
			sb.WriteString("\t}\n")
			sb.WriteString("\tif length > 0 {\n")
			fmt.Fprintf(sb, "\t\te.%s = string(data[offset:offset + int(length)])\n", field.Name)
			sb.WriteString("\t}\n")
			sb.WriteString("\toffset += int(length)\n\n")
		case "[]byte":
			sb.WriteString("\tlength = binary.LittleEndian.Uint32(data[offset:])\n")
			sb.WriteString("\toffset += 4\n")
			sb.WriteString("\tif flag & awe.Crc32 == 0 && len(data) < offset + int(length) {\n")
			sb.WriteString("\t\treturn io.ErrUnexpectedEOF\n")
			sb.WriteString("\t}\n")
			sb.WriteString("\tif length > 0 {\n")
			sb.WriteString("\t\tif flag & awe.FastUnmarshal > 0 {\n")
			fmt.Fprintf(sb, "\t\t\te.%s = data[offset : offset + int(length)]\n", field.Name)
			sb.WriteString("\t\t} else {\n")
			fmt.Fprintf(sb, "\t\t\te.%s = make([]byte, length)\n", field.Name)
			fmt.Fprintf(sb, "\t\t\tcopy(e.%s, data[offset : offset + int(length)])\n", field.Name)
			sb.WriteString("\t\t}\n")
			sb.WriteString("\t}\n")
			sb.WriteString("\toffset += int(length)\n\n")
		default:
			if strings.HasPrefix(field.Type, "[") && strings.HasSuffix(field.Type, "]byte") {
				arraySize := strings.TrimPrefix(field.Type, "[")
				arraySize = strings.TrimSuffix(arraySize, "]byte")
				sb.WriteString(fmt.Sprintf("\tif flag & awe.Crc32 == 0 && len(data) < offset + %s {\n", arraySize))
				sb.WriteString("\t\treturn io.ErrUnexpectedEOF\n")
				sb.WriteString("\t}\n")
				sb.WriteString(fmt.Sprintf("\tcopy(e.%s[:], data[offset:offset + %s])\n", field.Name, arraySize))
				sb.WriteString(fmt.Sprintf("\toffset += %s\n\n", arraySize))
			}
		}
	}
	sb.WriteString("\treturn nil\n}\n\n")
}
